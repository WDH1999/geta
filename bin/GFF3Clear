#!/usr/bin/perl
use strict;
use Getopt::Long;

my $usage = <<USAGE;
Usage:
    perl $0 [options] file1.gff3 file2.gff3 ... > total.gff3

    程序用于读取一个或多个GFF3文件，对GFF3文件格式进行修正，仅保留编码蛋白基因，并去除CDS区有重叠的冗余基因模型。

    1. 输入的GFF3文件格式要求：必须包含mRNA、CDS这两个Feature信息，且其第九列含有Parent信息; 也可以包含exon和UTR信息; 所有输入的额GFF3文件中的所有基因具有不同的ID编号。程序仅读取GFF3文件的mRNA、CDS、exon信息。
    2. 程序对GFF3文件按如下顺序进行行修正：
        2.1 若输入GFF3文件中不包含exon，则程序根据CDS信息生成exon信息和CDSs之间的intron信息；
        2.2 若输入GFF3文件中包含exon，且exon比CDS范围要多时，则生成UTRs之间的intron信息；
        2.3 若一个mRNA内有两CDSs之间的碱基距离 < 指定阈值，则程序在标准错误输出中给出警告信息，不进行处理；
        2.4 若一个mRNA内有两个exons之间的碱基距离 < 0，则程序将较长的exon根据intron打断；
        2.5 根据输入的基因组序列信息，程序检测基因模型尾部CDS是否包含终止密码子。若不包含，则程序在基因组序列中检测后续的3个碱基是否为终止密码子，从而修正CDS范围，使之包含终止密码子；
        2.6 程序对每个gene的mRNA进行了CDS和exon的完善，检测基因的完整性信息，得到UTR和intron信息，并能将这些信息输出到GFF3结果文件中；
        2.7 在一个GFF3文件中，若有两个或多个基因在同一条链上的CDS区域有重叠，则按基因CDS的长度（若存在可变剪接，则是所有isoform的所有CDSs去冗余后的长度），从短到长去除基因模型，保证两两基因模型的CDS区重叠覆盖率（相对较短基因CDS长度的比例）<= 指定阈值；
        2.8 当输入多个GFF3文件时，检测到基因在同一条链上的CDS区重叠覆盖率（相对较短基因CDS长度的比例）> 指定阈值时，则去除后输入文件的基因模型;
        2.9 程序最后对基因模型按输入的基因序列顺序及位置信息进行排序，然后根据需要对基因ID进行重命名，输出去冗余的标准GFF3格式的基因模型信息。

    3. 参数信息：
    --genome <string>
    输入基因组fasta文件。该参数是必须的，用于修正尾部的CDS和基因完整性检测。

    --min_intron <int>    default: 1
    设置一个最短intron长度阈值。当检测到相邻两CDSs之间相距的碱基距离 < 该阈值时，程序会标准错误输出中给出警告信息。当使用默认参数 1 时，出现警告表示基因模型有错误。

    --coverage <int>    default: 0.30
    设置一个覆盖度阈值。当两个基因型模型CDS重叠区碱基数 / 较小基因模型CDS去冗余碱基数 > 该覆盖度阈值时， 则去除相应的基因模型。若该值设置为 1，则表示不会去除冗余的基因模型；设置为 0，则表示在CDS区重叠 >= 1 bp，也会去除冗余的基因模型。

    --gene_prefix <string>    default: None
    若设置该参数，则程序会对基因ID进行重命名，该参数用于设置gene ID前缀。若不设置该参数，则程序不会对基因进行重命名。

    --gene_code_length <int>    default: none
    设置基因数字编号的长度。若不添加改参数，则程序根据基因的数量自动计算出基因数字编号的长度。例如，基因总数量为10000~99999时，基因数字编号长度为5，于是第一个基因编号为00001；若基因总数量在1000~9999时，基因数字编号长度为4，第一个基因编号为0001。设置该参数用于强行指定基因编号的长度，从而决定基因编号前0的数量。若某个基因的编号数值长度 >= 本参数设置的值，则该基因编号数值前不加0。

    --no_attr_add <bool>     default: None
    添加该参数，则不在GFF3文件第9列添加Source和Integrity信息。

USAGE
if(@ARGV==0){die $usage}

my ($genome, $min_intron, $coverage, $gene_prefix, $gene_code_length,  $no_attr_add);
GetOptions(
    "genome:s" => \$genome,
    "min_intron:i" => \$min_intron,
    "coverage:f" => \$coverage,
    "gene_prefix:s" => \$gene_prefix,
    "gene_code_length:i" => \$gene_code_length,
    "no_attr_add!" => \$no_attr_add,
);
die "--genome should be set\n" unless $genome;
$min_intron ||= 1;
$coverage ||= 0.3;

# 读取基因组序列
open IN, $genome or die $!;
my (%seq, $seq_id, @seq_id);
while (<IN>) {
    chomp;
    if (m/^>(\S+)/) {
        $seq_id = $1;
        push @seq_id, $1 unless $seq{$1};
    }
    else {
        $seq{$seq_id} .= $_;
    }
}
close IN;

# 读取GFF3文件
my (%gff, %sort1, %sort2, %sort3, %sort4, %CDS);
foreach my $input_file ( @ARGV ) {

    # 每读取一个GFF3文件，则将其编码蛋白信息存储在 %gff3 中
    # 读取GFF3文件的mRNA、CDS和exon信息。若有 gene 信息，则保存其 attribute 信息
    open IN, $input_file or die "can not open file $input_file, $!";
    my ( %lines, $gene_id, $mRNA_id, %gff3_attr, %mRNAID2geneID );
	# 先读取gene和mRNA信息，存储GFF3第9列attribute信息，得到mRNA ID和gene ID之间的对应关系
	while ( <IN> ) {
		if ( m/\tmRNA\t/ ) {
			@_ = split /\t/;
			if ( $_[8] =~ /ID=([^;\s]+)/ ) {
				$mRNA_id = $1;
			}
			else {
				die "In the GFF3 File $input_file, mRNA Feature have no ID information: $_";
			}

			if ( $_[8] =~ /Parent=([^;\s]+)/ ) {
				$gene_id = $1;
			}
			else {
				die "In the GFF3 File $input_file, mRNA Feature have no Parent information: $_";
			}
			$mRNAID2geneID{$mRNA_id} = $gene_id;

			$gff3_attr{$mRNA_id} = &get_attr($_[8]);
		}
		elsif ( m/\tgene\t/) {
			@_ = split /\t/;
			if ( $_[8] =~ /ID=([^;\s]+)/ ) {
				$gene_id = $1;
				$gff3_attr{$gene_id} r($_[8]);
			}
			else {
				die "In the GFF3 File $input_file, gene Feature have no ID information: $_";
			}
		}
	}

	# 再读取CDS和exon信息，得到 gene -> mRNA -> CDS/exon 信息。
	my %gff3;
	while ( <IN> ) {
		next if m/^#/;
		next if m/^\s*$/;
		next if exists $lines{$_};
		$lines{$_} = 1;
		@_ = split /\t/;

		if ( $_[2] eq "CDS" or  $_[2] eq "exon" ) {
			if ( $_[8] =~ /Parent=([^;\s]+)/ ) {
				$gff3{$mRNAID2geneID{$1}}{$1} .= $_;
			}
			else {
				die "In the GFF3 File $input_file, CDS/exon Feature have no Parent information: $_";
			}
		}
	}

    # 对mRNA的CDS和exon进行修正
	my %gff3_m;
	foreach my $gene_ID ( keys %gff3 ) {
		foreach my $mRNA_ID ( keys %{$gff3{$gene_ID}} ) {
			my $info = $gff3{$gene_ID}{$mRNA_ID};
			$info =~ s/^\s*//;
			$info =~ s/\s*$//;
			my @info = split /\n/, $info;
			@_ = split /\t/, $info[0];
			my ( $chr, $source, $strand ) = ( $_[0], $_[1], $_[6] );

			my ( @CDS, @exon, @CDS_exon, @exon_exon, @intron, @UTR );
			foreach ( @info ) {
				@_ = split /\t/;
				push @CDS, "$_[3]\t$_[4]" if $_[2] eq "CDS";
				push @CDS_exon, "$_[3]\t$_[4]" if $_[2] eq "CDS";
				push @exon_exon, "$_[3]\t$_[4]" if $_[2] eq "exon";
			}

			@exon = &modify_exon(\@CDS_exon, \@exon_exon)
			my %intron1 = &(@CDS);
			my %intron2 = &get_intron(@exon);
			foreach (keys %intron1) 

		}
	}

    my %cds;
    foreach my $gene_id (keys %gff_info) {
        my $gff_info = $gff_info{$gene_id};
        # 去除不含 CDS 信息的基因模型
        unless ($gff_info =~ m/\tCDS\t/) {
            delete $gff_info{$gene_id};
            print STDERR "Delete gene without CDS information: $gene_id\n";
            next;
        }
        foreach (split /\n/, $gff_info) {
            if (m/^(\S+?)\t.*\tCDS\t(\d+?)\t(\d+?)\t.*?\t(.*?)\t/) {
                my $index1 = int($2 / 1000);
                my $index2 = int($3 / 1000);
                foreach ($index1 .. $index2) {
                    $cds{$1}{$4}{$_}{"$2\t$3"} = $gene_id;
                }
            }
        }
    }

    my %overlap;
    foreach my $gene_id (keys %gff_info) {
        my $gff_info = $gff_info{$gene_id};
        foreach (split /\n/, $gff_info) {
            if (m/^(\S+?)\t.*\tCDS\t(\d+?)\t(\d+?)\t.*?\t(.*?)\t/) {
                my $index1 = int($2 / 1000);
                my $index2 = int($3 / 1000);
                foreach my $index ( $index1 .. $index2 ) {
                    foreach (keys %{$cds{$1}{$4}{$index}}) {
                        @_ = split /\t/;
                        if ($_[1] >= $2 && $_[0] <= $3 && $gene_id ne $cds{$1}{$4}{$index}{$_}) {
                            $overlap{$gene_id}{$cds{$1}{$4}{$index}{$_}} = 1;
                            #print STDERR "$gene_id\t$2\t$3\t$cds{$1}{$4}{$index}{$_}\t$_[0]\t$_[1]\n";
                        }
                    }
                }
            }
        }
    }

    my %cluster;
    while (%overlap) {
        my %cluster_one;

        my @overlap = keys %overlap;
        my $one = shift @overlap;
        my @one;
        push @one, $one;

        while (@one) {
            $one = shift @one;
            $cluster_one{$one} = 1;
            if (exists $overlap{$one}) {
                foreach (keys %{$overlap{$one}}) {
                    push @one, $_;
                }
                delete $overlap{$one};
            }
        }

        my $cluster = join "\t", keys %cluster_one;
        $cluster{$cluster} = 1;
    }

    foreach my $cluster (keys %cluster) {
        my @genes = split /\t/, $cluster;
        @genes = sort {$gene_length{$a} <=> $gene_length{$b}} @genes;
        my %genes_for_delete;
        foreach (@genes) { $genes_for_delete{$_} = 1; }
        # 根据CDS长度从短到长删除和其它基因CDS有重叠的基因。
        foreach my $gene_id (@genes) {
            delete $genes_for_delete{$gene_id};
            # 得到这些重叠基因类的所有的CDS信息。
            my %gene_cds;
            foreach my $gene_id_d (keys %genes_for_delete) {
                my $gff_info_d = $gff_info{$gene_id_d};
                foreach (split /\n/, $gff_info_d) {
                    if (m/^(\S+?)\t.*\tCDS\t(\d+?)\t(\d+?)\t.*?\t(.*?)\t/) {
                        my $index1 = int($2 / 1000);
                        my $index2 = int($3 / 1000);
                        foreach ($index1 .. $index2) {
                            $gene_cds{$1}{$4}{$_}{"$2\t$3"} = $gene_id_d;
                        }

                    }
                }
            }
            # 当前基因的CDS和其它基因CDS有重叠，则删除该基因信息。
            my $gff_info = $gff_info{$gene_id};
            F1: foreach (split /\n/, $gff_info) {
                if (m/^(\S+?)\t.*\tCDS\t(\d+?)\t(\d+?)\t.*?\t(.*?)\t/) {
                    my $index1 = int($2 / 1000);
                    my $index2 = int($3 / 1000);
                    foreach my $index ( $index1 .. $index2 ) {
                        foreach (keys %{$gene_cds{$1}{$4}{$index}}) {
                            @_ = split /\t/;
                            if ($_[1] >= $2 && $_[0] <= $3 && $gene_id ne $gene_cds{$1}{$4}{$index}{$_}) {
                                delete $gff_info{$gene_id} unless $no_rm_overlap_gene;
                                print STDERR "$gene_id\t$gene_cds{$1}{$4}{$index}{$_}: delete: $gene_id\n" unless $no_rm_overlap_gene;
                                last F1;
                            }
                        }
                    }
                }
            }
        }
    }

    my @gene_id = keys %gff_info;
    foreach my $gene_id (@gene_id) {
        my $gff_info = $gff_info{$gene_id};
        foreach (split /\n/, $gff_info) {
            if (m/^(\S+?)\t.*\tCDS\t(\d+?)\t(\d+?)\t.*?\t(.*?)\t/) {
                my $index1 = int($2 / 1000);
                my $index2 = int($3 / 1000);
                foreach my $index ( $index1 .. $index2 ) {
                    foreach (keys %{$CDS{$1}{$4}{$index}}) {
                        @_ = split /\t/;
                        if ($_[1] >= $2 && $_[0] <= $3 && $gene_id ne $CDS{$1}{$4}{$index}{$_}) {
                            delete $gff_info{$gene_id} unless $no_rm_overlap_gene;
                            print STDERR "$gene_id\t$CDS{$1}{$4}{$index}{$_}: delete: $gene_id\n" unless $no_rm_overlap_gene;
                        }
                    }
                }
            }
        }
    }

    foreach my $chr (keys %cds) {
        foreach my $strand (keys %{$cds{$chr}}) {
            foreach my $index (keys %{$cds{$chr}{$strand}}) {
                foreach (keys %{$cds{$chr}{$strand}{$index}}) {
                    $CDS{$chr}{$strand}{$index}{$_} = $cds{$chr}{$strand}{$index}{$_};
                }
            }
        }
    }

    foreach (keys %gff_info) {
        $gff{$_} = $gff_info{$_};
    }
}

# 对基因按位置进行排序
my @id = sort {$sort1{$a} cmp $sort1{$b} or $sort2{$a} <=> $sort2{$b} or $sort3{$a} <=> $sort3{$b} or $sort4{$a} cmp $sort4{$b}} keys %gff;
my $total_number = @id;
$total_number = length $total_number;
$total_number = $gene_code_length if $gene_code_length;
my $number;

# 读取基因的exon和CDS信息，添加UTR信息。也适用于含有可变剪接的GFF3文件。
foreach my $gene_id (@id) {
    next unless $gene_id;
    my $gff_info = $gff{$gene_id};
    next unless $gff_info =~ m/\tCDS\t/;
    my $out;
    $number ++;

    # 对gene的ID进行修改
    my $id_out = $gene_prefix . 0 x ($total_number - (length $number)) . $number;
    $gff_info =~ s/(\tgene\t.*\tID=)$gene_id/$1$id_out/;
    $gff_info =~ s/;?\n/;\n/;
    $gff_info =~ s/(\tgene\t.*)/${1}Source=$gene_id;/ unless $no_attr_add;
    my $gene_integrity = "incomplete";

    # 将gene的所有信息分割成mRNA信息
    my (%gff_mRNA, @mRNA_id, $mRNA_id, %mRNA_line, $gene_out);
    foreach (split /\n/, $gff_info) {
        if (m/\tgene\t/) {
            $gene_out = $_;
        }
        elsif (m/\tmRNA\t.*ID=([^;\s]+)/) {
            $mRNA_id = $1;
            $mRNA_line{$mRNA_id} = $_;
            push @mRNA_id, $mRNA_id;
        }
        elsif (m/\tCDS\t/ or m/\texon\t/) {
            $gff_mRNA{$mRNA_id} .= "$_\n";
        }
    }

    # 对mRNA信息进行分析：验证是否完整、修改ID、添加UTR
    my $mRNA_number = 0;
    foreach (@mRNA_id) {
        my $gff_mRNA = $gff_mRNA{$_};
        next unless $gff_mRNA =~ m/\tCDS\t/;
        $mRNA_number ++;

        # 修改mRNA的ID和Parent信息。
        my $transcript_id = "$id_out.t$mRNA_number";
        my $mRNA_line = $mRNA_line{$_};
        $mRNA_line =~ s/ID=[^;\s]+;?//;
        $mRNA_line =~ s/Parent=[^;\s]+;?//;
        $mRNA_line =~ s/\t([^\t]*)$/\tID=$transcript_id;Parent=$id_out;$1/;

        # 由CDSs得到exons，和已有的exons进行整合：（1）一个exon和另外一个exon有重叠，则选择exon长的；（2）若一个exon和多个exons有重叠，则去掉该exon，对多个exon进行延长。
        $gff_mRNA = &modify_exon($gff_mRNA, $transcript_id);

        # 修改CDS和exon的ID和Parent信息。若没有exon信息，则根据CDS信息得到exon信息。
        #$gff_mRNA = &change_id($gff_mRNA, $transcript_id);

        # 进行基因完整性验证。
        my %info = &cdsIncludeStopCodon_and_integrity($gff_mRNA, $transcript_id);
        $gff_mRNA = $info{"info"};
        my $integrity = $info{"integrity"};
        $gene_integrity = "complete" if $integrity eq "complete";

        $mRNA_line =~ s/;?$/;Integrity=$integrity;/ unless $no_attr_add;
        $out .= "$mRNA_line\n";

        # 添加UTR信息。
        $gff_mRNA = &addUTR($gff_mRNA, $transcript_id);

        my $sortgff = &sortgff($gff_mRNA);
        $out .= $sortgff;
    }

    $gene_out =~ s/;?$/;Integrity=$gene_integrity;/ unless $no_attr_add;
    print "$gene_out\n$out\n";
}

sub sortgff {
    my $out;
    my $info = $_[0];
    my @line = split /\n/, $info;
    @_ = split /\t/, $line[0];
    my $strand = $_[6];
    my %sort;
    foreach (@line) {
        @_ = split /\t/;
        if ($_[2] eq "gene") {
            $out .= "$_\n";
        }
        elsif ($_[2] eq "mRNA") {
            $out .= "$_\n";
        }
        elsif ($_[2] eq "CDS" or $_[2] eq "exon" or $_[2] eq "five_prime_UTR" or $_[2] eq "three_prime_UTR") {
            $sort{$_} = $_[3];
        }
    }

    if ($strand eq "+") {
        foreach (sort {$sort{$a} <=> $sort{$b} or $b cmp $a } keys %sort) {
            $out .= "$_\n";
        }
    }
    elsif ($strand eq "-") {
        foreach (sort {$sort{$b} <=> $sort{$a} or $b cmp $a } keys %sort) {
            $out .= "$_\n";
        }
    }

    return $out;
}

sub modify_exon {
    my $info = $_[0];
    my $gene_id = $_[1];

    my @line = split /\n/, $info;
    @_ = split /\t/, $line[0];
    my ($f1, $f2, $strand) = ($_[0], $_[1], $_[6]);

    my (%cds_exon, %exon, %cds_info);
    foreach (@line) {
        s/\t[^\t]+$//;
        @_ = split /\t/;
        if (m/\tCDS\t/) {
            $cds_info{"$_[3]\t$_[4]"} = $_;
            $cds_exon{"$_[3]\t$_[4]"} = 1;
        }
        elsif (m/\texon\t/) {
            $exon{"$_[3]\t$_[4]"} = 1;
        }
    }

    my @exon = sort {$a <=> $b} keys %exon;
    my @cds_exon = sort {$a <=> $b} keys %cds_exon;

    # 首先，首尾CDS得到的exon可能被包含在含有UTR的exon中。这是第一种exons之间的重叠，选择有UTR的exon信息（选择更长的exon）。
    # =========----=======---=======
    # +++======----=======---==+++++
    # 以上示例中，选择前者exon信息
    my $cds_exon_start = shift @cds_exon;
    my ($start, $end) = split /\t/, $cds_exon_start;
    # 若CDS得到的exon能被已有的exons覆盖，则不需要其exon信息。
    my $keep = 1;
    foreach (@exon) {
        @_ = split /\t/, $_;
        if ($_[0] <= $start && $_[1] == $end) {
            $keep = 0;
            #print "OK1:\t$_\n";
            last;
        }
    }
    $exon{$cds_exon_start} = 1 if $keep == 1;
    if (@cds_exon) {
        my $cds_exon_end = pop @cds_exon;
        ($start, $end) = split /\t/, $cds_exon_end;
        $keep = 1;
        foreach (@exon) {
            @_ = split /\t/, $_;
            if ($_[0] == $start && $_[1] >= $end) {
                $keep = 0;
                #print "OK1:\t$_\n";
                last;
            }
        }
        $exon{$cds_exon_end} = 1 if $keep == 1;
    }
    foreach (@cds_exon) {
        $exon{$_} = 1;
    }

    # 此外，再对所有的exons之间的重叠进行分析，这是第二种exons之间的重叠，则将更长的exon进行打断，选择更短的exon。
    # ==============================
    #   ====----========---=====
    # 以上示例中出现了4个exons，则选择较短的exons，并将和3个exons有重叠的第一个exon进行打断，得到的3个exons如下：
    # ======----========---=========
    @exon = sort {$a <=> $b} keys %exon;
    my $first_exon = shift @exon;
    my ($last_start, $last_end) = split /\t/, $first_exon;
    my ($stop_end, @exon_out);
    foreach (@exon) {
        my ($start, $end) = split /\t/, $_;
        if ($start > $last_end) {
            push @exon_out, "$last_start\t$last_end";
            #print "OK2:\t$last_start\t$last_end\n";
            ($last_start, $last_end) = ($start, $end);
        }
        else {
            $stop_end = $last_end if $stop_end < $last_end;
            $last_end = $end;
        }
    }
    $last_end = $stop_end if $stop_end > $last_end;
    push @exon_out, "$last_start\t$last_end";
    #print "OK2:\t$last_start\t$last_end\n";

    my @cds_out = keys %cds_info;
    if ($strand eq "+") {
        @cds_out = sort {$a <=> $b} @cds_out;
        @exon_out = sort {$a <=> $b} @exon_out;
    }
    elsif ($strand eq "-") {
        @cds_out = sort {$b <=> $a} @cds_out;
        @exon_out = sort {$b <=> $a} @exon_out;
    }

    my $out;
    my $cds_num = 0;
    foreach (@cds_out) {
        $cds_num ++;
        $out .= "$cds_info{$_}\tID=$gene_id.CDS$cds_num;Parent=$gene_id;\n";
    }
    my $exon_num = 0;
    foreach (@exon_out) {
        $exon_num ++;
        $out .= "$f1\t$f2\texon\t$_\t\.\t$strand\t\.\tID=$gene_id.exon$exon_num;Parent=$gene_id;\n";
    }

    return $out;
}

sub change_id {
    my $info = $_[0];
    my $gene_id = $_[1];

    my @line = split /\n/, $info;
    @_ = split /\t/, $line[0];
    my $strand = $_[6];

    my (%cds, %exon);
    foreach (@line) {
        s/\t[^\t]+$//;
        @_ = split /\t/;
        if (m/\tCDS\t/) {
            $cds{$_} = $_[3];
        }
        elsif (m/\texon\t/) {
            $exon{$_} = $_[3];
        }
    }

    my (@cds, @exon);
    if ($strand eq "+") {
        @cds = sort {$cds{$a} <=> $cds{$b}} keys %cds;
        @exon = sort {$exon{$a} <=> $exon{$b}} keys %exon;
    }
    elsif ($strand eq "-") {
        @cds = sort {$cds{$b} <=> $cds{$a}} keys %cds;
        @exon = sort {$exon{$b} <=> $exon{$a}} keys %exon;
    }

    my $out;
    my $cds_num = 0;
    foreach (@cds) {
        $cds_num ++;
        $out .= "$_\tID=$gene_id.CDS$cds_num;Parent=$gene_id;\n";
        unless (@exon) {
            s/\tCDS\t/\texon\t/;
            $out .= "$_\tID=$gene_id.exon$cds_num;Parent=$gene_id;\n";
        }
    }
    my $exon_num = 0;
    foreach (@exon) {
        $exon_num ++;
        $out .= "$_\tID=$gene_id.exon$exon_num;Parent=$gene_id;\n";
    }

    return $out;
}

sub addUTR {
    my $info = $_[0];
    my $gene_id = $_[1];

    my @line = split /\n/, $info;
    @_ = split /\t/, $line[0];
    my ($seqID, $strand) = ($_[0], $_[6]);

    my (@cds, @exon, @utr, %cds_pos);
    foreach (@line) {
        @_ = split /\t/;
        if ($_[2] eq 'CDS') {
            push @cds, "$_[3]\t$_[4]";
            $cds_pos{$_[3]} = 1;
            $cds_pos{$_[4]} = 1;
        }
        elsif ($_[2] eq 'exon') {
            push @exon, "$_[3]\t$_[4]";
        }
    }

    foreach (@exon) {
        my ($start, $end) = split /\t/;
        my $utr_keep = 1;
        foreach (@cds) {
            @_ = split /\t/;
            if ($_[0] <= $end && $_[1] >= $start) {
                $utr_keep = 0;
                if ($start < $_[0] && $end == $_[1]) {
                    my $utr_start = $start;
                    my $utr_end = $_[0] - 1;
                    push @utr, "$utr_start\t$utr_end";
                }
                elsif ($start == $_[0] && $end > $_[1]) {
                    my $utr_start = $_[1] + 1;
                    my $utr_end = $end;
                    push @utr, "$utr_start\t$utr_end";
                }
            }
        }
        push @utr, $_ if $utr_keep == 1;
    }

    my @cds_pos = sort {$a <=> $b} keys %cds_pos;
    my ($utr5num, $utr3num);
    if ($strand eq "+") {
        @utr = sort {$a <=> $b} @utr;
        foreach (@utr) {
            @_ = split /\t/;
            if ($_[1] <= $cds_pos[0]) {
                $utr5num ++;
                $info .= "$seqID\t\.\tfive_prime_UTR\t$_\t\.\t$strand\t\.\tID=$gene_id.5UTR$utr5num;Parent=$gene_id;\n";
            }
            elsif ($_[0] >= $cds_pos[1]) {
                $utr3num ++;
                $info .= "$seqID\t\.\tthree_prime_UTR\t$_\t\.\t$strand\t\.\tID=$gene_id.3UTR$utr3num;Parent=$gene_id;\n";
            }
        }
    }
    elsif ($strand eq "-") {
        @utr = sort {$b <=> $a} @utr;
        foreach (@utr) {
            @_ = split /\t/;
            if ($_[0] >= $cds_pos[1]) {
                $utr5num ++;
                $info .= "$seqID\t\.\tfive_prime_UTR\t$_\t\.\t$strand\t\.\tID=$gene_id.5UTR$utr5num;Parent=$gene_id;\n";
            }
            elsif ($_[1] <= $cds_pos[0]) {
                $utr3num ++;
                $info .= "$seqID\t\.\tthree_prime_UTR\t$_\t\.\t$strand\t\.\tID=$gene_id.3UTR$utr3num;Parent=$gene_id;\n";
            }
        }
    }

    return $info;
}
sub cdsIncludeStopCodon_and_integrity {
    # 输入一个genemodel的GFF3信息
    my $info = $_[0];
    my $gene_id = $_[1];
    my @line = split /\n/, $info;
    @_ = split /\t/, $line[0];
    my ($seqID, $strand) = ($_[0], $_[6]);

    my @cds;
    foreach (@line) {
        @_ = split /\t/;
        push @cds, "$_[3]\t$_[4]\t$_[7]" if $_[2] eq 'CDS';
    }
    @cds = sort { $a <=> $b } @cds;
    @_ = split /\t/, $cds[0];
    my $frame = $_[2];

    my $cds_seq;
    foreach (@cds) {
        @_ = split /\t/;
        my $start = $_[0] - 1;
        my $len = $_[1] - $start;
        $cds_seq .= substr($seq{$seqID}, $start, $len);
    }

    if ($strand eq "-") {
        @_ = split /\t/, $cds[-1];
        $frame = $_[2];
        $cds_seq = reverse $cds_seq;
        $cds_seq =~ tr/ATCGatcg/TAGCTAGC/;
    }

    $cds_seq =~ s/^\w{$frame}//;
    my $pep_seq = &cds2pep($cds_seq, $gene_id);

    if ($pep_seq =~ s/(\*+)\*$/\*/) {
        my $extra_stop_codon_length = length($1);
        if ($strand eq "+") {
            my ($start, $end, $frame) = split /\t/, $cds[-1];
            $frame = ($end + 1 - $start - $frame) % 3;
            $frame = 1 if $frame == 2;
            $frame = 2 if $frame == 1;
            if ($frame == 0) {
                my $end3 = $end - (3 * $extra_stop_codon_length);
                $info =~ s/^(\S+\t\S+\t\S+\t\d+)\t$end\t/$1\t$end3\t/mg;
            }
        }
        elsif ($strand eq "-") {
            my ($start, $end, $frame) = split /\t/, $cds[0];
            $frame = ($end + 1 - $start - $frame) % 3;
            $frame = 1 if $frame == 2;
            $frame = 2 if $frame == 1;
            if ($frame == 0 && $start > 3) {
                my $start3 = $start + (3 * $extra_stop_codon_length);
                $info =~ s/^(\S+\t\S+\t\S+)\t$start\t/$1\t$start3\t/mg;
            }
        }
    }

    unless ($pep_seq =~ m/\*$/) {
        my $next_codon;
        if ($strand eq "+") {
            my ($start, $end, $frame) = split /\t/, $cds[-1];
            $frame = ($end + 1 - $start - $frame) % 3;
            $frame = 1 if $frame == 2;
            $frame = 2 if $frame == 1;
            if ($frame == 0) {
                my $codon = substr($seq{$seqID}, $end, 3);
                #print "OK1:\t$gene_id\t$frame\t$seqID\t$start\t$end\t$codon\n";
                if ($codon eq "TAA" or $codon eq "TGA" or $codon eq "TAG") {
                    my $end3 = $end + 3;
                    #print "$info\n";
                    $info =~ s/^(\S+\t\S+\t\S+\t\d+)\t$end\t/$1\t$end3\t/mg;
                    #print "$info\n";
                    $pep_seq .= '*';
                }
            }
        }
        elsif ($strand eq "-") {
            my ($start, $end, $frame) = split /\t/, $cds[0];
            $frame = ($end + 1 - $start - $frame) % 3;
            $frame = 1 if $frame == 2;
            $frame = 2 if $frame == 1;
            if ($frame == 0 && $start > 3) {
                my $codon = substr($seq{$seqID}, ($start - 4), 3);
                $codon = reverse $codon;
                $codon =~ tr/ATCGatcg/TAGCTAGC/;
                #print "OK2:\t$gene_id\t$frame\t$seqID\t$start\t$end\t$codon\n";
                if ($codon eq "TAA" or $codon eq "TGA" or $codon eq "TAG") {
                    my $start3 = $start - 3;
                    #print "$info\n";
                    $info =~ s/^(\S+\t\S+\t\S+)\t$start\t/$1\t$start3\t/mg;
                    #print "$info\n";
                    $pep_seq .= '*';
                }
            }
        }
    }

    my ($integrity, $start_ok, $end_ok);
    if ($pep_seq =~ m/^M/) {$start_ok = 1}
    if ($pep_seq =~ m/\*$/) {$end_ok = 1}
    if ($start_ok == 1 && $end_ok == 1) { $integrity = "complete" }
    elsif ($start_ok == 1 && $end_ok != 1) { $integrity = "3prime_partial" }
    elsif ($start_ok != 1 && $end_ok == 1) { $integrity = "5prime_partial" }
    elsif ($start_ok != 1 && $end_ok != 1) { $integrity = "internal" }

    my %out;
    $out{"info"} = $info;
    $out{"integrity"} = $integrity;
    return %out;
}

sub cds2pep {
    my %cds2pep = (
        "TTT" => "F",
        "TTC" => "F",
        "TTA" => "L",
        "TTG" => "L",
        "TCT" => "S",
        "TCC" => "S",
        "TCA" => "S",
        "TCG" => "S",
        "TAT" => "Y",
        "TAC" => "Y",
        "TAA" => "*",
        "TAG" => "*",
        "TGT" => "C",
        "TGC" => "C",
        "TGA" => "*",
        "TGG" => "W",
        "CTT" => "L",
        "CTC" => "L",
        "CTA" => "L",
        "CTG" => "L",
        "CCT" => "P",
        "CCC" => "P",
        "CCA" => "P",
        "CCG" => "P",
        "CAT" => "H",
        "CAC" => "H",
        "CAA" => "Q",
        "CAG" => "Q",
        "CGT" => "R",
        "CGC" => "R",
        "CGA" => "R",
        "CGG" => "R",
        "ATT" => "I",
        "ATC" => "I",
        "ATA" => "I",
        "ATG" => "M",
        "ACT" => "T",
        "ACC" => "T",
        "ACA" => "T",
        "ACG" => "T",
        "AAT" => "N",
        "AAC" => "N",
        "AAA" => "K",
        "AAG" => "K",
        "AGT" => "S",
        "AGC" => "S",
        "AGA" => "R",
        "AGG" => "R",
        "GTT" => "V",
        "GTC" => "V",
        "GTA" => "V",
        "GTG" => "V",
        "GCT" => "A",
        "GCC" => "A",
        "GCA" => "A",
        "GCG" => "A",
        "GAT" => "D",
        "GAC" => "D",
        "GAA" => "E",
        "GAG" => "E",
        "GGT" => "G",
        "GGC" => "G",
        "GGA" => "G",
        "GGG" => "G",
    );
    my $seq = shift @_;
    $seq = uc($seq);
    my $gene = shift @_;
    my $pep;
    while ((length $seq) >= 3) {
        $seq =~ s/(\w{3})//;
        if (exists $cds2pep{$1}) {
            $pep .= $cds2pep{$1};
        }
        else {
            $pep .= 'X';
        }
    }
    #print STDERR "Warning: CDS length of $gene is not multiple of 3\n" if (length $seq) > 0;
    #print STDERR "Warning: Stop Codon appear in the middle of $gene\n" if $pep =~ m/\*\w/;
    return $pep;
}

sub get_attr {
	my $attribute = $_[0];
	my @attribute = split /;/, $attribute;
	my @out;
	foreach ( @attribute ) {
		s/^\s*//;
		s/\s*$//;
		next if m/^ID/i;
		next if m/^Parent/i;
		push @out, $_;
	}
	my $out = join ";", @out;
	return $out;
}
